<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>مصمم الدرج — Hybrid v3 (FIX7)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root{--bg:#0b1220;--panel:#121a2b;--muted:#1b2640;--text:#e8eefc;--sub:#9fb3d9;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Kufi Arabic",sans-serif}
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,var(--panel),#0e1627);border-bottom:1px solid #1f2a44}
    .row{display:flex;gap:.75rem;flex-wrap:wrap;align-items:center;padding:.75rem 1rem;transition:opacity .2s ease, transform .2s ease}
    label{font-size:.85rem;color:var(--sub)}
    input,select,button{background:#0f1730;border:1px solid #243256;color:#e8eefc;padding:.5rem .6rem;border-radius:.6rem}
    input[type="number"]{width:6.2rem}input[type="color"]{padding:0;border:none;background:transparent;width:2.2rem;height:2.2rem}
    input[type="range"]{width:8rem}button{cursor:pointer}.ghost{background:transparent;border-color:#2a3556}
    .layout{display:grid;grid-template-columns:1.2fr 1fr;gap:10px;padding:10px;min-height:calc(100vh - 210px)}
    .panel{background:linear-gradient(180deg,var(--panel),#0e1627);border:1px solid #1b2747;border-radius:1rem;overflow:hidden;display:flex;flex-direction:column}
    .panel-header{display:flex;justify-content:space-between;align-items:center;padding:.65rem 1rem;border-bottom:1px solid #1f2a44;background:rgba(255,255,255,.02)}
    .panel-header h3{margin:0;color:#cfe3ff;font-size:1rem}
    #boardToolbar{display:flex;gap:.75rem;align-items:center;padding:.5rem .75rem;border-bottom:1px solid #1f2a44;background:rgba(0,0,0,.15)}
    #board{position:relative}#boardCanvas{width:100%;height:100%;display:block;background:#0a0f1d;cursor:grab}#boardCanvas:active{cursor:grabbing}
    .badge{position:absolute;top:.5rem;left:.5rem;background:#0d1732;border:1px solid #223055;padding:.25rem .5rem;border-radius:.5rem;color:#bcd0f7;font-size:.8rem}
    #threeCanvas{display:block;width:100%;height:100%;background:#060b16}
    .inspector{position:absolute;inset:auto 1rem 1rem auto;width:320px;max-height:65vh;overflow:auto;background:#0d1730;border:1px solid #25345a;border-radius:1rem;padding:.75rem;box-shadow:0 10px 30px rgba(0,0,0,.4);z-index:20}
    .stepRow{display:grid;grid-template-columns:auto 1fr;gap:.5rem;align-items:center;margin:.35rem 0}.small{font-size:.8rem;color:#9fb3d9}
    #safetyIndicator{margin-left:1rem;padding:.4rem .8rem;border-radius:.6rem;font-size:.85rem;font-weight:500;border:1px solid;display:flex;align-items:center;gap:.5rem}
    .control-chip{display:flex;align-items:center;gap:.5rem;background:#0f1730;border:1px solid #243256;padding:.4rem .6rem;border-radius:.6rem}
    .inspector h4{margin:.25rem 0 .5rem}.muted{opacity:.85}

    /* ===== Fullscreen HUD (CSS-gated) ===== */
    #fsHud{display:none;position:absolute;inset:8px 8px auto 8px;flex-wrap:wrap;gap:.5rem;align-items:center;background:rgba(10,15,29,.75);backdrop-filter:blur(6px);border:1px solid #25345a;border-radius:.8rem;padding:.5rem .6rem;z-index:30}
    #fsHud label{color:#cfe3ff;font-size:.8rem}
    #fsHud input[type="range"]{width:120px}
    #fsHud select{max-width:230px}
    #fsHud .sep{width:1px;height:24px;background:#233154;margin-inline:.25rem}
    #fsHud .grow{flex:1 1 auto}
    #threeWrap:fullscreen #fsHud{display:flex}
    #threeWrap:-webkit-full-screen #fsHud{display:flex}

    /* Solo-3D mode (hide 2D panel, expand 3D) */
    body.solo-3d .layout{grid-template-columns:1fr}
    body.solo-3d #boardWrap{display:none}

    /* FPS badge */
    #fpsBadge{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.45);border:1px solid #2a3556;border-radius:.5rem;padding:.25rem .5rem;font-size:.8rem;color:#cfe3ff;z-index:35;pointer-events:none}
    #fpsBadge.good{color:#a7f3d0} #fpsBadge.mid{color:#fde68a} #fpsBadge.bad{color:#fecaca}

    @media (max-width:980px){.layout{grid-template-columns:1fr;grid-template-rows:45vh 65vh;height:auto;padding:5px;gap:5px}.inspector{max-height:50vh;width:calc(100% - 2rem)}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="row">
        <strong>🛠️ مصمم الدرج</strong>
        <span class="small">Hybrid Splash + RectArea — v3 FIX7</span>
      </div>

      <div class="row" id="stairRow" style="gap:1rem;align-items:center">
        <div id="safetyIndicator"><span id="safetyIcon"></span><span id="safetyText"></span></div>
        <div><label>عدد الدرج</label><br/><input id="inpSteps" type="number" min="1" max="200" value="12"/></div>
        <div><label>عرض الدرج (متر)</label><br/><input id="inpWidth" type="number" min="0.3" step="0.05" value="1.20"/></div>
        <div><label>عمق الدرجة (متر)</label><br/><input id="inpTreadDepth" type="number" min="0.15" step="0.01" value="0.30"/></div>
        <div><label>ارتفاع القائم (متر)</label><br/><input id="inpRiser" type="number" min="0.10" step="0.01" value="0.17"/></div>
        <div><label>سُمك الدرجة (متر)</label><br/><input id="inpThickness" type="number" min="0.01" step="0.005" value="0.03"/></div>

        <div class="control-chip">
          <label>لون موحد:</label><input id="inpColor" type="color" value="#8d9aaf">
          <div class="sep"></div>
          <button id="btnApplyTexture" class="ghost" title="تطبيق خامة الرخام">تطبيق خامة الرخام</button>
        </div>

        <button id="btnResetCam" class="ghost">إعادة ضبط الكاميرا</button>
      </div>

      <div class="row" id="lightRow" style="gap:1rem;align-items:center;border-top:1px solid #1f2a44">
        <label class="small">سطوع المشهد:</label><input id="sunIntensity" type="range" min="0" max="3" step="0.05" value="1.2">
        <div class="sep"></div>

        <label class="small">نمط LED:</label>
        <select id="ledPattern">
          <option value="sequenceUp">متسلسل ↑ (من تحت)</option>
          <option value="sequenceDown">متسلسل ↓ (من فوق)</option>
          <option value="edgeIn">من الأطراف → للوسط</option>
          <option value="edgeOut">من المنتصف ← للأطراف</option>
          <option value="wave">موجة (5 نِقاط)</option>
          <option value="chaseUp">تتابعي ↑ (3 نِقاط)</option>
          <option value="chaseDown">تتابعي ↓ (3 نِقاط)</option>
          <option value="pulse">نبضي متقدّم</option>
          <option value="sparkle">عشوائي ناعم</option>
        </select>

        <label class="small">لون LED:</label>
        <input id="ledColor" type="color" value="#fff5cc" title="لون الإضاءة"/>

        <label class="small">سرعة LED:</label>
        <input id="ledSpeed" type="range" min="0.1" max="3" step="0.05" value="1"/>

        <div class="sep"></div>

        <div class="control-chip">
          <label class="small">عدد الأضواء الفعلي:</label>
          <input id="areaCount" type="range" min="0" max="12" step="1" value="12">
          <span id="areaCountLabel" class="small">12</span>
          <label class="small" style="margin-inline-start:.5rem">شدة المساحة:</label>
          <input id="areaIntensity" type="range" min="2" max="20" step="0.5" value="8">
          <span id="areaIntensityLabel" class="small">8</span>
        </div>

        <div class="sep"></div>
        <label class="small">المدّة (ث):</label>
        <input id="patternDuration" type="number" min="0" step="1" value="0" style="width:4.5rem" title="0 = بدون توقيت">
        <span id="patternCountdown" class="small" style="min-width:5rem;display:inline-block;opacity:.85"></span>
        <button id="btnRunPattern">تشغيل النمط</button>
        <button id="btnToggleInspector" class="ghost">تحكم يدوي LED</button>
        <button id="btnLightReset" class="ghost">إعادة ضبط الإضاءة</button>
        <button id="btnFullscreen">تكبير شاشة 3D</button>

        <div class="sep"></div>
        <div class="control-chip">
          <label class="small">الجودة:</label>
          <select id="qualityPreset" title="Quality Preset">
            <option value="auto">تلقائي</option>
            <option value="high">عالية</option>
            <option value="medium" selected>متوسطة</option>
            <option value="low">منخفضة</option>
          </select>
          <span class="small" id="qualityHint">DR:1024 PR:1.0</span>
        </div>
        <button id="btnSave" class="ghost" title="حفظ الإعدادات">حفظ</button>
        <button id="btnLoad" class="ghost" title="تحميل الإعدادات">تحميل</button>
      </div>
    </header>

    <main class="layout" id="mainLayout">
      <section class="panel" id="boardWrap">
        <div class="panel-header"><h3>منطقة الرسم 2D</h3></div>
        <div id="boardToolbar"><span class="small">تحريك: عجلة الفأرة + سحب بزر أوسط</span></div>
        <div id="board"><canvas id="boardCanvas"></canvas><div class="badge" id="hud">تكبير: 100% | أصل: 0,0</div></div>
      </section>

      <section class="panel" id="threeWrap">
        <div class="panel-header">
          <h3>المعاينة ثلاثية الأبعاد</h3>
          <div class="small">RectAreaLight + Splash Quads — بدون Bloom</div>
        </div>
        <div style="position:relative;flex:1">
          <canvas id="threeCanvas"></canvas>
          <div id="fpsBadge">-- FPS</div>

          <!-- Fullscreen HUD -->
          <div id="fsHud">
            <label>سطوع:</label>
            <input id="fsSun" type="range" min="0" max="3" step="0.05">
            <div class="sep"></div>

            <label>النمط:</label>
            <select id="fsPattern">
              <option value="sequenceUp">متسلسل ↑</option>
              <option value="sequenceDown">متسلسل ↓</option>
              <option value="edgeIn">الأطراف→الوسط</option>
              <option value="edgeOut">المنتصف→الأطراف</option>
              <option value="wave">موجة</option>
              <option value="chaseUp">تتابعي ↑</option>
              <option value="chaseDown">تتابعي ↓</option>
              <option value="pulse">نبضي</option>
              <option value="sparkle">عشوائي</option>
            </select>

            <label>اللون:</label>
            <input id="fsColor" type="color">

            <label>السرعة:</label>
            <input id="fsSpeed" type="range" min="0.1" max="3" step="0.05" style="width:110px">

            <label>المدة (ث):</label>
            <input id="fsDuration" type="number" min="0" step="1" style="width:4.5rem">

            <button id="fsRun">تشغيل النمط</button>
            <span class="grow"></span>
            <button id="fsExit" class="ghost">تصغير الشاشة</button>
          </div>

          <aside class="inspector" id="inspector" hidden>
            <h4>إضاءة LED يدوي</h4>
            <div class="muted" style="margin-bottom:.35rem">فتح التحكم اليدوي يوقف أي نمط تلقائيًا.</div>
            <div class="stepRow"><span class="small">شدة (الكل):</span><input type="range" id="intensity" min="0" max="5" step="0.05" value="1.5"></div>
            <div id="stepsInspector"></div>
          </aside>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.159.0";
    import { OrbitControls } from "https://esm.sh/three@0.159.0/examples/jsm/controls/OrbitControls.js";
    import { RectAreaLightUniformsLib } from "https://esm.sh/three@0.159.0/examples/jsm/lights/RectAreaLightUniformsLib.js";
    RectAreaLightUniformsLib.init();

    const el = id => document.getElementById(id);
    const num = (v, fb) => { const n=parseFloat(v); return Number.isFinite(n)?n:fb; };
    const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));

    /* ===== Scroll-driven UI collapse ===== */
    const stairRow = el('stairRow');
    const boardWrap = el('boardWrap');
    let row1H = 0;
    let uiProgress = 0; // 0..1
    function measureHeights(){
      row1H = stairRow.offsetHeight;
      stairRow.style.height = row1H + 'px';
    }
    function applyUIScroll(){
      const p = clamp(uiProgress, 0, 1);
      const p1 = Math.min(p/0.5, 1);           // 0..0.5 collapses stairRow
      const p2 = Math.max(0, (p-0.5)/0.5);     // 0.5..1 hides 2D panel

      stairRow.style.height = (row1H*(1-p1)) + 'px';
      stairRow.style.opacity = (1-p1).toFixed(3);
      stairRow.style.transform = `translateY(${ -10*p1 }px)`;
      stairRow.style.pointerEvents = (p1>0.98) ? 'none' : 'auto';

      boardWrap.style.opacity = (1-p2).toFixed(3);
      boardWrap.style.transform = `translateY(${ 20*p2 }px) scale(${ 1 - 0.02*p2 })`;
      if (p2 >= 1){
        if (!document.body.classList.contains('solo-3d')){
          document.body.classList.add('solo-3d');
          resizeThree();
        }
      } else {
        if (document.body.classList.contains('solo-3d')){
          document.body.classList.remove('solo-3d');
          resizeBoard();
          resizeThree();
        }
      }
    }
    function onWheelCollapse(e){
      const t = e.target;
      if (t && (t.id==='boardCanvas' || t.id==='threeCanvas')) return;
      uiProgress = clamp(uiProgress + (e.deltaY*0.0012), 0, 1);
      applyUIScroll();
    }
    function initTouchCollapse(){
      let lastY = null;
      window.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches.length){ lastY = e.touches[0].clientY; }}, {passive:true});
      window.addEventListener('touchmove', (e)=>{
        if (lastY==null) return;
        const y = e.touches[0].clientY;
        const dy = lastY - y;
        lastY = y;
        const t = e.target;
        if (t && (t.id==='boardCanvas' || t.id==='threeCanvas')) return;
        uiProgress = clamp(uiProgress + (dy*0.003), 0, 1);
        applyUIScroll();
      }, {passive:true});
      window.addEventListener('touchend', ()=>{ lastY=null; }, {passive:true});
    }
    window.addEventListener('wheel', onWheelCollapse, {passive:true});

    /* ======= 2D ======= */
    const boardCanvas = el('boardCanvas'), hud = el('hud');
    const ctx2d = boardCanvas.getContext('2d');
    const board = { zoom:1, origin:{x:80,y:120}, pan:{x:0,y:0}, baseGrid:40 };
    function m2px(m){ return m*100*board.baseGrid/100*board.zoom; }
    function resizeBoard(){
      if (!boardCanvas) return;
      const rect=boardCanvas.parentElement.getBoundingClientRect();
      boardCanvas.width=Math.floor(rect.width*devicePixelRatio);
      boardCanvas.height=Math.floor(rect.height*devicePixelRatio);
      boardCanvas.style.width=rect.width+'px'; boardCanvas.style.height=rect.height+'px';
      ctx2d.setTransform(1,0,0,1,0,0); ctx2d.scale(devicePixelRatio,devicePixelRatio);
      drawBoard();
    }
    function drawGrid(){
      const cell=board.baseGrid*board.zoom, ox=board.origin.x+board.pan.x%cell, oy=board.origin.y+board.pan.y%cell;
      ctx2d.save(); ctx2d.lineWidth=1; ctx2d.strokeStyle='rgba(128,160,220,.25)';
      for(let x=ox;x<boardCanvas.clientWidth;x+=cell){ctx2d.beginPath();ctx2d.moveTo(x,0);ctx2d.lineTo(x,boardCanvas.clientHeight);ctx2d.stroke();}
      for(let y=oy;y<boardCanvas.clientHeight;y+=cell){ctx2d.beginPath();ctx2d.moveTo(0,y);ctx2d.lineTo(boardCanvas.clientWidth,y);ctx2d.stroke();}
      ctx2d.strokeStyle='rgba(76,201,240,.75)'; ctx2d.beginPath(); ctx2d.moveTo(0,board.origin.y+board.pan.y); ctx2d.lineTo(boardCanvas.clientWidth,board.origin.y+board.pan.y); ctx2d.stroke();
      ctx2d.beginPath(); ctx2d.moveTo(board.origin.x+board.pan.x,0); ctx2d.lineTo(boardCanvas.clientWidth,0); ctx2d.stroke();
      ctx2d.restore();
    }
    function drawStair2D(){
      const pxD=m2px(state.treadDepth), pxW=m2px(state.width);
      const startX=board.origin.x+board.pan.x, startY=board.origin.y+board.pan.y;
      ctx2d.save(); ctx2d.translate(0.5,0.5);
      for(let i=0;i<state.steps;i++){
        const x=startX, y=startY+i*pxD;
        ctx2d.fillStyle=i%2?'rgba(123,147,181,.18)':'rgba(123,147,181,.28)';
        ctx2d.strokeStyle='rgba(200,220,255,.45)'; ctx2d.lineWidth=1;
        ctx2d.fillRect(x,y,pxW,pxD-2); ctx2d.strokeRect(x,y,pxW,pxD-2);
        ctx2d.strokeStyle='rgba(255,255,255,.25)';
        ctx2d.beginPath(); ctx2d.moveTo(x,y+pxD-2); ctx2d.lineTo(x+pxW,y+pxD-2); ctx2d.stroke();
      }
      ctx2d.restore();
    }
    function drawBoard(){
      const w=boardCanvas.clientWidth,h=boardCanvas.clientHeight;
      ctx2d.clearRect(0,0,w,h);
      const g=ctx2d.createLinearGradient(0,0,0,h); g.addColorStop(0,'#0a0f1d'); g.addColorStop(1,'#0b1220');
      ctx2d.fillStyle=g; ctx2d.fillRect(0,0,w,h);
      drawGrid(); drawStair2D();
      hud.textContent = `تكبير: ${Math.round(board.zoom*100)}% | أصل: ${Math.round(board.pan.x)},${Math.round(board.pan.y)}`;
    }
    boardCanvas.addEventListener('wheel',(e)=>{e.preventDefault(); const prev=board.zoom,f=Math.exp(-e.deltaY*0.0015); board.zoom=clamp(board.zoom*f,0.2,5); const mx=e.offsetX,my=e.offsetY; board.pan.x = mx - (mx - board.pan.x - board.origin.x)*(board.zoom/prev) - board.origin.x; board.pan.y = my - (my - board.pan.y - board.origin.y)*(board.zoom/prev) - board.origin.y; drawBoard();},{passive:false});
    let dragging=false,last={x:0,y:0};
    boardCanvas.addEventListener('mousedown',(e)=>{ if(e.button!==1 && e.button!==2) return; dragging=true; last.x=e.clientX; last.y=e.clientY; });
    window.addEventListener('mousemove',(e)=>{ if(!dragging) return; const dx=e.clientX-last.x, dy=e.clientY-last.y; board.pan.x+=dx; board.pan.y+=dy; last.x=e.clientX; last.y=e.clientY; drawBoard(); });
    window.addEventListener('mouseup',()=>dragging=false);

    /* ============ 3D ============ */
    const threeCanvas = el('threeCanvas');
    const renderer = new THREE.WebGLRenderer({canvas:threeCanvas, antialias:true});
    renderer.setPixelRatio(1.0);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.08;
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.physicallyCorrectLights = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x060b16);
    const camera = new THREE.PerspectiveCamera(55,1,0.1,100);
    const controls = new OrbitControls(camera, threeCanvas); controls.enableDamping=true;

    function resizeThree(){
      const rect = threeCanvas.parentElement.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width/rect.height; camera.updateProjectionMatrix();
    }

    const ambLight = new THREE.AmbientLight(0xffffff,0.20); scene.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffffff,1.20);
    dirLight.position.set(5,10,7);
    dirLight.castShadow = true; dirLight.shadow.mapSize.set(1024,1024);
    scene.add(dirLight);

    const sunSlider = el('sunIntensity');
    function applySun(v){ dirLight.intensity=v; ambLight.intensity=0.20*(0.6+0.4*(v/1.2)); }
    applySun(num(sunSlider.value,1.2)); sunSlider.addEventListener('input', ()=> applySun(num(sunSlider.value,1.2)));

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x0c1424,roughness:0.9}));
    floor.rotation.x=-Math.PI/2; floor.position.y=-0.01; floor.receiveShadow=true; scene.add(floor);

    const textureLoader = new THREE.TextureLoader();
    function loadTex(path){
      return textureLoader.load(
        path,
        (tex)=>{ tex.colorSpace = THREE.SRGBColorSpace; tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = quality.current.aniso; tex.generateMipmaps = true; if(state.mode==='texture') buildStair(); },
        undefined,
        (err)=> console.warn('لم يتم تحميل', path, err)
      );
    }

    const state = {
      steps: num(el('inpSteps').value,12),
      width: num(el('inpWidth').value,1.2),
      treadDepth: num(el('inpTreadDepth').value,0.3),
      riser: num(el('inpRiser').value,0.17),
      thickness: num(el('inpThickness').value,0.03),
      color: el('inpColor').value,
      mode: 'color',
      stepLights: [],
      splashMats: [],
      ledAreas: [],
      areaPoolSize: 12,
      areaIntensity: num(el('areaIntensity').value, 8),
      activeCount: 12,
      treadTex: loadTex('tread.png'),
      riserTex: loadTex('riser.png'),
      manualActive: false,
      treadsIM: null,
      risersIM: null
    };

    const riserDepth = 0.02;
    const ledDepth   =  Math.min(0.04, state.treadDepth*0.25);
    const overhang   = ledDepth;
    const effectiveDepth = state.treadDepth - overhang;

    const treadMatColor = ()=> new THREE.MeshStandardMaterial({ color:new THREE.Color(state.color), roughness:0.6, metalness:0.05, side: THREE.FrontSide });
    const riserMatColor = ()=> new THREE.MeshStandardMaterial({ color:new THREE.Color(state.color).clone().multiplyScalar(0.95), roughness:0.8, metalness:0.03, side: THREE.FrontSide });
    const treadMatTex = ()=> new THREE.MeshStandardMaterial({ map: state.treadTex, roughness:0.6, metalness:0.1, side: THREE.FrontSide });
    const riserMatTex = ()=> new THREE.MeshStandardMaterial({ map: state.riserTex, roughness:0.8, metalness:0.05, side: THREE.FrontSide });

    const stairGroup = new THREE.Group(); scene.add(stairGroup);

    function resetCamera(){
      const totalRun = effectiveDepth*(state.steps-1) + state.treadDepth;
      const totalRise = state.riser*state.steps;
      const size = Math.max(totalRun, totalRise*1.2, state.width);
      camera.position.set(size*1.2, size, size*1.2);
      controls.target.set(state.width/2, totalRise/2, totalRun/2); controls.update();
    }

    function ensureAreaPool(colorHex){
      while (state.ledAreas.length < state.areaPoolSize){
        const l = new THREE.RectAreaLight(new THREE.Color(colorHex), state.areaIntensity, state.width*0.98, ledDepth);
        l.visible = false;
        scene.add(l);
        state.ledAreas.push(l);
      }
      while (state.ledAreas.length > state.areaPoolSize){
        const l = state.ledAreas.pop();
        scene.remove(l);
      }
    }

    function disposeIM(im){
      if(!im) return;
      if(im.geometry) im.geometry.dispose();
      if(im.material) im.material.dispose();
      scene.remove(im);
    }

    function buildStair(){
      // clear old dynamic parts
      state.stepLights=[]; state.splashMats=[];
      while(stairGroup.children.length) stairGroup.remove(stairGroup.children[0]);
      disposeIM(state.treadsIM); disposeIM(state.risersIM);
      state.treadsIM = null; state.risersIM = null;

      // Instanced treads & risers
      const treadGeo = new THREE.BoxGeometry(state.width, state.thickness, state.treadDepth);
      const riserGeo = new THREE.BoxGeometry(state.width, state.riser, riserDepth);
      const ledGeo   = new THREE.BoxGeometry(state.width*0.98, 0.006, ledDepth);

      const treadMat = state.mode==='texture'? treadMatTex(): treadMatColor();
      const riserMat = state.mode==='texture'? riserMatTex(): riserMatColor();

      const treadsIM = new THREE.InstancedMesh(treadGeo, treadMat, state.steps);
      const risersIM = new THREE.InstancedMesh(riserGeo, riserMat, state.steps);
      treadsIM.castShadow = true; treadsIM.receiveShadow = true;
      risersIM.castShadow = true; risersIM.receiveShadow = true;

      const m4 = new THREE.Matrix4();
      for(let i=0;i<state.steps;i++){
        const y = i*state.riser, z = i*effectiveDepth;
        m4.makeTranslation(state.width/2, y + state.riser + state.thickness/2, z + state.treadDepth/2 - overhang);
        treadsIM.setMatrixAt(i, m4);
        m4.makeTranslation(state.width/2, y + state.riser/2, z);
        risersIM.setMatrixAt(i, m4);
      }
      treadsIM.instanceMatrix.needsUpdate = true;
      risersIM.instanceMatrix.needsUpdate = true;
      stairGroup.add(treadsIM); stairGroup.add(risersIM);
      state.treadsIM = treadsIM; state.risersIM = risersIM;

      // Non-instanced LEDs & splash (need per-step intensity)
      const colorHex = el('ledColor').value;
      for(let i=0;i<state.steps;i++){
        const y = i*state.riser, z = i*effectiveDepth;

        const ledMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(colorHex),
          emissive: new THREE.Color(colorHex),
          emissiveIntensity: 0.0, roughness:0.95
        });
        const led = new THREE.Mesh(ledGeo, ledMat);
        led.position.set(
          state.width/2,
          y + state.riser - 0.003,
          z + state.treadDepth/2 - overhang - state.treadDepth/2 + ledDepth/2
        );
        led.castShadow=false; led.receiveShadow=false; stairGroup.add(led);
        state.stepLights.push(led.material);

        const splashGeo = new THREE.PlaneGeometry(state.width*0.96, ledDepth*2.0);
        const splashMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(colorHex),
          transparent: true,
          opacity: 0.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        const splash = new THREE.Mesh(splashGeo, splashMat);
        splash.rotation.x = -Math.PI/2;
        splash.position.set(
          state.width/2,
          y + state.riser - 0.0005,
          z + (state.treadDepth*0.5 - overhang*0.5)
        );
        splash.renderOrder = 2;
        stairGroup.add(splash);
        state.splashMats.push(splashMat);
      }

      const countSlider = el('areaCount');
      countSlider.max = String(state.steps);
      if ((parseInt(countSlider.value,10) === 0) || (parseInt(countSlider.value,10) > state.steps)){
        countSlider.value = String(state.steps);
      }
      state.activeCount = parseInt(countSlider.value,10) || state.steps;
      el('areaCountLabel').textContent = String(state.activeCount);

      state.areaPoolSize = state.activeCount;
      ensureAreaPool(colorHex);
      resetCamera();
      if (!inspector.hidden) buildInspector();
    }

    /* ====== Controls ====== */
    const intensitySlider = el('intensity'), durationInput = el('patternDuration'), countdownEl = el('patternCountdown');
    const patternSel = el('ledPattern'), ledColorPicker = el('ledColor'), ledSpeed = el('ledSpeed');
    const btnRunPattern = el('btnRunPattern'), btnLightReset = el('btnLightReset');
    const btnToggleInspector = el('btnToggleInspector');
    const inspector = el('inspector'), stepsInspector = el('stepsInspector');
    const areaCount = el('areaCount'), areaCountLabel = el('areaCountLabel');
    const areaIntensity = el('areaIntensity'), areaIntensityLabel = el('areaIntensityLabel');
    const qualityPresetSel = el('qualityPreset'), qualityHint = el('qualityHint');
    const btnSave = el('btnSave'), btnLoad = el('btnLoad');
    const fpsBadge = el('fpsBadge');

    function applyLEDColor(hex){
      const c = new THREE.Color(hex);
      state.stepLights.forEach(m=>{ m.color=c; m.emissive=c; });
      state.splashMats.forEach(m=>{ m.color=c; });
      state.ledAreas.forEach(l=> l.color=c);
    }
    ledColorPicker.addEventListener('input', ()=> applyLEDColor(ledColorPicker.value));

    function setAllEmissive(v){
      for (let i=0;i<state.stepLights.length;i++){
        const on = i < state.activeCount;
        state.stepLights[i].emissiveIntensity = on? v : 0;
        state.splashMats[i].opacity = on? v*0.9 : 0;
      }
      state.ledAreas.forEach(l=> { l.intensity = 0; l.visible = false; });
    }
    if (intensitySlider){
      intensitySlider.addEventListener('input', ()=> { 
        state.manualActive = true; 
        cancelAnimationFrame(raf);
        setAllEmissive(num(intensitySlider.value,0));
        const val = num(intensitySlider.value,0);
        stepsInspector.querySelectorAll('input[type="range"][data-step]').forEach(inp=>{ inp.value = String(val); });
      });
    }

    function buildInspector(){
      stepsInspector.innerHTML = '';
      for(let i=0;i<state.stepLights.length;i++){
        const row = document.createElement('div');
        row.className = 'stepRow';
        const label = document.createElement('span');
        label.className = 'small';
        label.textContent = `درجة #${i+1}`;
        const rng = document.createElement('input');
        rng.type = 'range'; rng.min='0'; rng.max='5'; rng.step='0.05';
        rng.value = String(state.stepLights[i].emissiveIntensity || 0);
        rng.setAttribute('data-step', String(i));
        rng.addEventListener('input', ()=>{
          state.manualActive = true;
          cancelAnimationFrame(raf);
          const v = num(rng.value,0);
          state.stepLights[i].emissiveIntensity = v;
          state.splashMats[i].opacity = v * 0.9;
          state.ledAreas.forEach(l=>{ l.visible=false; l.intensity=0; });
        });
        row.appendChild(label); row.appendChild(rng);
        stepsInspector.appendChild(row);
      }
    }

    btnToggleInspector.addEventListener('click', (e)=>{
      e.stopPropagation();
      inspector.hidden = !inspector.hidden;
      if (!inspector.hidden){
        state.manualActive = true;
        cancelAnimationFrame(raf);
        buildInspector();
      }
    });
    document.addEventListener('pointerdown', (e)=>{
      if (!inspector.hidden && !inspector.contains(e.target) && e.target !== btnToggleInspector){
        inspector.hidden = true;
      }
    });

    /* ====== Quality Presets + FPS Auto ====== */
    const quality = {
      preset: 'medium',
      current: { name:'medium', pixelRatio: 1.0, shadow: 1024, aniso: 4 },
      levels: {
        high:   { name:'high',   pixelRatio: Math.min(2, window.devicePixelRatio||1.5), shadow:2048, aniso:8 },
        medium: { name:'medium', pixelRatio: 1.0, shadow:1024, aniso:4 },
        low:    { name:'low',    pixelRatio: 0.8, shadow:512,  aniso:1 }
      },
      apply(cfg){
        renderer.setPixelRatio(cfg.pixelRatio);
        dirLight.shadow.mapSize.set(cfg.shadow, cfg.shadow);
        dirLight.shadow.needsUpdate = true;
        [state.treadTex, state.riserTex].forEach(tex=>{ if(tex){ tex.anisotropy = cfg.aniso; tex.needsUpdate = true; } });
        resizeThree();
        quality.current = cfg;
        qualityHint.textContent = `DR:${cfg.shadow} PR:${cfg.pixelRatio.toFixed(2)}`;
      },
      toOrder(name){ return name==='high'?2:name==='medium'?1:0; }
    };
    function setPreset(name){
      quality.preset = name;
      const cfg = quality.levels[name] || quality.levels.medium;
      quality.apply(cfg);
    }
    qualityPresetSel.addEventListener('change', ()=> setPreset(qualityPresetSel.value));

    // FPS monitor + auto-throttle if preset=auto
    let fpsEMA = 60, lastTs = performance.now(), underTimer = 0, overTimer = 0;
    function updateFPS(now){
      const dt = Math.max(1, now - lastTs);
      lastTs = now;
      const fps = 1000/dt;
      // EMA smoothing
      fpsEMA = fpsEMA*0.9 + fps*0.1;
      // badge
      fpsBadge.textContent = `${fpsEMA.toFixed(0)} FPS`;
      if (fpsEMA >= 55) {
  fpsBadge.className = 'good';
} else if (fpsEMA >= 40) {
  fpsBadge.className = 'mid';
} else {
  fpsBadge.className = 'bad';
}

    }

    function autoQualityStep(dt){
      if (quality.preset !== 'auto') return;
      // thresholds
      if (fpsEMA < 45){
        underTimer += dt;
        overTimer = 0;
      } else if (fpsEMA > 58){
        overTimer += dt;
        underTimer = 0;
      } else {
        underTimer = overTimer = 0;
      }
      const order = quality.toOrder(quality.current.name);
      if (underTimer > 2.0 && order > 0){ // drop quality
        const next = order===2 ? 'medium' : 'low';
        quality.apply(quality.levels[next]);
        underTimer = 0;
      } else if (overTimer > 5.0 && order < 2){ // raise quality
        const next = order===1 ? 'high' : 'medium';
        quality.apply(quality.levels[next]);
        overTimer = 0;
      }
    }

    /* ====== Patterns ====== */
    let patternTimerId=null, countdownIntervalId=null, patternEndsAt=0, raf=null, tAccum=0;
    function clearPatternTimers(){ if(patternTimerId){clearTimeout(patternTimerId);patternTimerId=null;} if(countdownIntervalId){clearInterval(countdownIntervalId);countdownIntervalId=null;} countdownEl.textContent=''; patternEndsAt=0; }
    function turnOffAllLEDs(){ state.stepLights.forEach((m,i)=> { m.emissiveIntensity = (i<state.activeCount?0:0); }); state.splashMats.forEach((m,i)=> m.opacity = (i<state.activeCount?0:0)); state.ledAreas.forEach(l=> { l.intensity=0; l.visible=false; }); }

    function startPatternTimer(seconds){
      clearPatternTimers(); if(!seconds||seconds<=0) return;
      patternEndsAt=performance.now()+seconds*1000;
      countdownIntervalId=setInterval(()=>{ const msLeft=patternEndsAt-performance.now(); if(msLeft<=0){clearPatternTimers();countdownEl.textContent='0.0s';turnOffAllLEDs(); cancelAnimationFrame(raf); return;} countdownEl.textContent=(msLeft/1000).toFixed(1)+'s'; },100);
      patternTimerId=setTimeout(()=>{ clearPatternTimers(); turnOffAllLEDs(); cancelAnimationFrame(raf); }, seconds*1000);
    }

    function runPattern(){
      state.manualActive = false;
      cancelAnimationFrame(raf);
      const base = num(intensitySlider ? intensitySlider.value : 1.5,1.5);
      const spd = num(ledSpeed.value,1);
      const totalAll = state.stepLights.length;
      const L = Math.max(1, Math.min(state.activeCount, totalAll));
      tAccum = 0;

      function placeArea(values){
        const k = state.ledAreas.length;
        const idxs = ( ()=>{
          if (k<=0) return [];
          const pairs = values.map((v,i)=>({i,v})).sort((a,b)=> b.v - a.v);
          const out=[]; for(let j=0;j<k && j<pairs.length;j++){ if (pairs[j].v>0.01) out.push(pairs[j].i); }
          return out;
        })();
        for(let kidx=0;kidx<state.ledAreas.length;kidx++){
          const l = state.ledAreas[kidx];
          const j = idxs[kidx];
          if (j==null){ l.visible=false; continue; }
          const y = j*state.riser, z = j*effectiveDepth;
          l.width = state.width*0.98; l.height = ledDepth;
          l.position.set(state.width/2, y + state.riser - 0.004, z + state.treadDepth*0.5 - overhang);
          l.lookAt(l.position.x, l.position.y - 1, l.position.z);
          const vj = clamp(values[j], 0, 10);
          l.intensity = Math.max(0, vj) * (state.areaIntensity/ (base||1));
          l.visible = vj > 0.02;
        }
      }

      function applyAll(vs){
        for (let i=0;i<totalAll;i++){
          const v = (i<L) ? Math.max(0, vs[i]) : 0;
          state.stepLights[i].emissiveIntensity = v;
          state.splashMats[i].opacity = v * 0.9;
        }
        placeArea(vs.slice(0,L));
      }

      // Sequence Up / Down: fill, then off, repeat
      let seqPhase = 0;
      function sequenceCore(dt, fromTop){
        const speed = 6 * spd;
        seqPhase += dt * speed;
        const vs = new Array(L).fill(0);
        if (seqPhase < L){
          const litCount = Math.floor(seqPhase) + 1;
          for (let k=0;k<litCount && k<L;k++){
            const i = fromTop ? (L-1-k) : k;
            vs[i] = base;
          }
        } else if (seqPhase < L + 1){
          // blackout
        } else {
          seqPhase = 0;
        }
        applyAll(vs);
      }
      function sequenceUp(dt){ sequenceCore(dt, false); }
      function sequenceDown(dt){ sequenceCore(dt, true); }

      // EdgeIn / EdgeOut: exactly two lights
      let edgePos = 0;
      function edgeIn(dt){
        const speed = 6 * spd;
        edgePos += dt*speed;
        const mid = (L-1)/2;
        if (edgePos >= mid){ edgePos = 0; }
        const left = Math.floor(edgePos);
        const right = L-1 - Math.floor(edgePos);
        const vs = new Array(L).fill(0);
        if (L>=1) vs[left] = base;
        if (L>=2) vs[right] = base;
        applyAll(vs);
      }
      function edgeOut(dt){
        const speed = 6 * spd;
        edgePos += dt*speed;
        const startL = Math.floor((L-1)/2);
        const startR = startL + (L%2===0 ? 1 : 0);
        const idx = Math.floor(edgePos);
        const iL = Math.max(0, startL - idx);
        const iR = Math.min(L-1, startR + idx);
        if (iL===0 && iR===L-1 && (edgePos - Math.floor(edgePos))>0.99){ edgePos = 0; }
        const vs = new Array(L).fill(0);
        vs[iL] = base; vs[iR] = base;
        applyAll(vs);
      }

      // Wave 5-lobe bouncing
      let wCenter = 2; let wVel = 6 * spd;
      const wKernel = [0.2, 0.6, 1.0, 0.6, 0.2];
      function wave(dt){
        const radius = 2;
        wCenter += wVel*dt;
        if (wCenter > (L-1)-radius){ wCenter = (L-1)-radius; wVel *= -1; }
        if (wCenter < 0+radius){ wCenter = radius; wVel *= -1; }
        const c = wCenter;
        const vs = new Array(L).fill(0);
        for(let k=-2;k<=2;k++){
          const idx = Math.round(c)+k;
          if (idx>=0 && idx<L){
            vs[idx] = base * wKernel[k+2];
          }
        }
        applyAll(vs);
      }

      // ChaseUp/Down 3-lobe
      let cuCenter = 1;
      const cKernel = [0.5, 1.0, 0.5];
      function chaseUp(dt){
        const speed = 8 * spd;
        cuCenter = (cuCenter + dt*speed) % L;
        const vs = new Array(L).fill(0);
        const c = cuCenter;
        for(let k=-1;k<=1;k++){
          let idx = Math.floor(c)+k;
          idx = (idx%L+L)%L;
          vs[idx] = base * cKernel[k+1];
        }
        applyAll(vs);
      }
      let cdCenter = L-2;
      function chaseDown(dt){
        const speed = 8 * spd;
        cdCenter = (cdCenter - dt*speed);
        while (cdCenter < 0) cdCenter += L;
        const vs = new Array(L).fill(0);
        const c = cdCenter;
        for(let k=-1;k<=1;k++){
          let idx = Math.floor(c)+k;
          idx = (idx%L+L)%L;
          vs[idx] = base * cKernel[k+1];
        }
        applyAll(vs);
      }

      // Advanced Pulse cycle
      let pulsePhase = 0;
      function pulse(dt){
        const vs = new Array(L).fill(0);
        const T_up = 1.2/ spd;
        const T_hard_on = 0.18/ spd;
        const T_hard_off = 0.18/ spd;
        const T_gap = 0.15/ spd;
        const cycle = 2*(T_up+T_gap) + 2*(T_hard_on+T_hard_off) + 0.5/ spd;
        pulsePhase = (pulsePhase + dt) % cycle;
        let v = 0;
        let t = pulsePhase;
        if (t < T_up){
          v = base * (t/T_up);
        } else if (t < T_up + T_gap){
          v = 0;
        } else if (t < T_up*2 + T_gap){
          v = base * ((t - (T_up + T_gap))/T_up);
        } else {
          const t2 = t - (2*T_up + T_gap);
          const block = T_hard_on + T_hard_off;
          if (t2 < block){
            v = (t2 < T_hard_on) ? base : 0;
          } else if (t2 < 2*block){
            const tt = t2 - block;
            v = (tt < T_hard_on) ? base : 0;
          } else {
            v = 0;
          }
        }
        for(let i=0;i<L;i++) vs[i]=v;
        applyAll(vs);
      }

      function sparkle(dt){
        tAccum += dt*spd;
        const vs = new Array(L);
        for(let i=0;i<L;i++){
          const n = (Math.sin(i*13.37 + tAccum*7.0)*0.5+0.5);
          vs[i] = base*(0.2+0.8*n);
        }
        applyAll(vs);
      }

      const modes = {sequenceUp, sequenceDown, edgeIn, edgeOut, wave, chaseUp, chaseDown, pulse, sparkle};
      const fn = modes[patternSel.value] || sequenceUp;

      let last=performance.now();
      function loop(now){
        const dt=Math.min(0.05, (now-last)/1000); last=now;
        if (!state.manualActive){
          fn(dt);
          raf = requestAnimationFrame(loop);
        }
      }
      raf = requestAnimationFrame(loop);

      const dur=parseInt(durationInput.value,10)||0; startPatternTimer(dur);
    }

    el('btnRunPattern').addEventListener('click', runPattern);
    window.addEventListener('keydown', e=>{ if(e.key==='p') runPattern(); });

    btnLightReset.addEventListener('click', ()=>{
      el('sunIntensity').value=1.2; applySun(1.2);
      if (intensitySlider) intensitySlider.value=1.5;
      el('ledSpeed').value=1; el('ledColor').value="#fff5cc"; el('ledPattern').value="sequenceUp";
      applyLEDColor(el('ledColor').value);
      clearPatternTimers(); turnOffAllLEDs();
      state.manualActive = false;
    });

    /* ====== Fullscreen & HUD sync ====== */
    const btnFullscreen = el('btnFullscreen');
    const threeWrap = el('threeWrap');
    const fsSun = el('fsSun');
    const fsPattern = el('fsPattern');
    const fsColor = el('fsColor');
    const fsSpeed = el('fsSpeed');
    const fsDuration = el('fsDuration');
    const fsRun = el('fsRun');
    const fsExit = el('fsExit');

    function syncFSFromMain(){
      fsSun.value = el('sunIntensity').value;
      fsPattern.value = patternSel.value;
      fsColor.value = ledColorPicker.value;
      fsSpeed.value = ledSpeed.value;
      fsDuration.value = durationInput.value;
    }
    function syncMainFromFS(){
      el('sunIntensity').value = fsSun.value; applySun(num(fsSun.value,1.2));
      patternSel.value = fsPattern.value;
      ledColorPicker.value = fsColor.value; applyLEDColor(fsColor.value);
      ledSpeed.value = fsSpeed.value;
      durationInput.value = fsDuration.value;
    }

    document.addEventListener('fullscreenchange', ()=>{
      if (document.fullscreenElement === threeWrap){
        syncFSFromMain();
        setTimeout(resizeThree, 150);
      } else {
        setTimeout(resizeThree, 150);
      }
    });

    btnFullscreen.addEventListener('click', async ()=>{
      try{
        if (document.fullscreenElement !== threeWrap){
          await (threeWrap.requestFullscreen?.() || threeWrap.webkitRequestFullscreen?.());
        } else {
          await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
        }
      }catch(err){ console.warn('Fullscreen failed', err); }
    });
    fsExit.addEventListener('click', async ()=>{
      try{ await (document.exitFullscreen?.() || document.webkitExitFullscreen?.()); }catch(e){}
    });

    // HUD sync both ways
    fsSun.addEventListener('input', ()=>{ syncMainFromFS(); });
    fsPattern.addEventListener('change', ()=>{ syncMainFromFS(); });
    fsColor.addEventListener('input', ()=>{ syncMainFromFS(); });
    fsSpeed.addEventListener('input', ()=>{ syncMainFromFS(); });
    fsDuration.addEventListener('input', ()=>{ syncMainFromFS(); });
    fsRun.addEventListener('click', ()=>{ syncMainFromFS(); runPattern(); });

    // main -> FS while in fullscreen
    el('sunIntensity').addEventListener('input', ()=>{ if (document.fullscreenElement===threeWrap) fsSun.value = el('sunIntensity').value; });
    patternSel.addEventListener('change', ()=>{ if (document.fullscreenElement===threeWrap) fsPattern.value = patternSel.value; });
    ledColorPicker.addEventListener('input', ()=>{ if (document.fullscreenElement===threeWrap) fsColor.value = ledColorPicker.value; });
    ledSpeed.addEventListener('input', ()=>{ if (document.fullscreenElement===threeWrap) fsSpeed.value = ledSpeed.value; });
    durationInput.addEventListener('input', ()=>{ if (document.fullscreenElement===threeWrap) fsDuration.value = durationInput.value; });

    // Slider handlers
    areaCount.addEventListener('input', ()=>{
      const v = Math.min(parseInt(areaCount.value,10)||0, state.steps);
      state.activeCount = Math.max(0, v);
      areaCountLabel.textContent = String(state.activeCount);
      state.areaPoolSize = state.activeCount;
      ensureAreaPool(ledColorPicker.value);
    });
    areaIntensity.addEventListener('input', ()=>{
      state.areaIntensity = num(areaIntensity.value, 8);
      areaIntensityLabel.textContent = String(state.areaIntensity);
      state.ledAreas.forEach(l=> l.intensity = state.areaIntensity);
    });

    // Save/Load presets to localStorage
    function gatherSettings(){
      return {
        steps: parseInt(el('inpSteps').value,10)||12,
        width: num(el('inpWidth').value,1.2),
        treadDepth: num(el('inpTreadDepth').value,0.3),
        riser: num(el('inpRiser').value,0.17),
        thickness: num(el('inpThickness').value,0.03),
        color: el('inpColor').value,
        mode: state.mode,
        sun: num(el('sunIntensity').value,1.2),
        pattern: el('ledPattern').value,
        ledColor: el('ledColor').value,
        speed: num(el('ledSpeed').value,1),
        duration: parseInt(el('patternDuration').value,10)||0,
        areaCount: parseInt(el('areaCount').value,10)||state.steps,
        areaIntensity: num(el('areaIntensity').value,8),
        quality: el('qualityPreset').value
      };
    }
    function applySettings(s){
      el('inpSteps').value = s.steps;
      el('inpWidth').value = s.width;
      el('inpTreadDepth').value = s.treadDepth;
      el('inpRiser').value = s.riser;
      el('inpThickness').value = s.thickness;
      el('inpColor').value = s.color;
      state.mode = s.mode || 'color';
      el('sunIntensity').value = s.sun; applySun(s.sun);
      el('ledPattern').value = s.pattern;
      el('ledColor').value = s.ledColor; applyLEDColor(s.ledColor);
      el('ledSpeed').value = s.speed;
      el('patternDuration').value = s.duration;
      el('areaCount').value = s.areaCount;
      el('areaIntensity').value = s.areaIntensity;
      el('qualityPreset').value = s.quality || 'medium';
      setPreset(el('qualityPreset').value);
      updateScene();
    }
    btnSave.addEventListener('click', ()=>{
      const s = gatherSettings();
      localStorage.setItem('stair_preset_default', JSON.stringify(s));
      btnSave.textContent = 'تم الحفظ ✓';
      setTimeout(()=> btnSave.textContent='حفظ', 800);
    });
    btnLoad.addEventListener('click', ()=>{
      const raw = localStorage.getItem('stair_preset_default');
      if (!raw){ btnLoad.textContent='لا يوجد حفظ'; setTimeout(()=> btnLoad.textContent='تحميل', 900); return; }
      try{
        const s = JSON.parse(raw);
        applySettings(s);
        btnLoad.textContent='تم التحميل ✓';
        setTimeout(()=> btnLoad.textContent='تحميل', 800);
      }catch(e){
        console.warn(e);
        btnLoad.textContent='خطأ في الملف';
        setTimeout(()=> btnLoad.textContent='تحميل', 900);
      }
    });

    // update scene on dimension change
    const inputs={steps:el('inpSteps'),width:el('inpWidth'),treadDepth:el('inpTreadDepth'),riser:el('inpRiser'),thickness:el('inpThickness'),color:el('inpColor')};
    function readUI(){
      state.steps=parseInt(inputs.steps.value)||12;
      state.width = num(inputs.width.value,1.2);
      state.treadDepth = num(inputs.treadDepth.value,0.3);
      state.riser = num(inputs.riser.value,0.17);
      state.thickness = num(inputs.thickness.value,0.03);
      state.color=inputs.color.value;
    }
    function updateScene(){
      readUI(); buildStair(); drawBoard(); updateSafetyIndicator(); applyLEDColor(el('ledColor').value);
    }
    Object.values(inputs).forEach(inp=> inp.addEventListener('input', updateScene));
    el('btnApplyTexture').addEventListener('click', ()=>{ state.mode='texture'; updateScene(); });
    inputs.color.addEventListener('input', ()=>{ state.mode='color'; updateScene(); });
    el('btnResetCam').addEventListener('click', resetCamera);

    function updateSafetyIndicator(){
      const ind=el('safetyIndicator'), icon=el('safetyIcon'), text=el('safetyText');
      const r=state.riser, t=state.treadDepth, s=(2*r)+t;
      if(s>=0.60 && s<=0.65){ ind.style.backgroundColor='rgba(34,197,94,.1)'; ind.style.borderColor='var(--ok)'; ind.style.color='#a3e6bd'; icon.textContent='✔'; text.textContent='أبعاد آمنة'; }
      else if(s>0.58 && s<0.68){ ind.style.backgroundColor='rgba(245,158,11,.1)'; ind.style.borderColor='var(--warn)'; ind.style.color='#fde68a'; icon.textContent='⚠️'; text.textContent='أبعاد مقبولة'; }
      else{ ind.style.backgroundColor='rgba(239,68,68,.1)'; ind.style.borderColor='var(--danger)'; ind.style.color='#fca5a5'; icon.textContent='❌'; text.textContent='أبعاد غير آمنة'; }
    }

    // Main render loop with FPS + auto quality
    function animate(){
      const now = performance.now();
      updateFPS(now);
      controls.update();
      renderer.render(scene,camera);
      const dt = 16/1000;
      autoQualityStep(dt);
      requestAnimationFrame(animate);
    }

    function init(){
      measureHeights();
      applyUIScroll();
      resizeBoard(); resizeThree();
      setPreset(qualityPresetSel.value);
      buildStair(); updateSafetyIndicator();
      // default active lights = steps
      state.activeCount = state.steps;
      const countSlider = el('areaCount');
      countSlider.max = String(state.steps);
      countSlider.value = String(state.steps);
      el('areaCountLabel').textContent = String(state.steps);
      state.areaPoolSize = state.steps; ensureAreaPool(el('ledColor').value);

      applyLEDColor(el('ledColor').value);
      el('areaIntensityLabel').textContent = el('areaIntensity').value;
      turnOffAllLEDs();

      initTouchCollapse();
      animate();
    }
    window.addEventListener('resize', ()=>{ resizeBoard(); resizeThree(); measureHeights(); applyUIScroll(); });
    init();
  </script>
</body>
</html>
